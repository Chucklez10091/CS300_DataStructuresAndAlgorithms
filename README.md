# CS300_DataStructuresAndAlgorithms

# What was the problem you were solving in the projects for this course?
  The goal of these projects was to implement an effective and effeicient method for temporarily storing and accessing a set of objects (courses in this case).

# How did you approach the problem? Consider why data structures are important to understand.
  I gave consideration to both the overall complexity of the operations needed, as well as how often each might likely be implemented. Given that the searching and sorted list printing operations were likely to be used more often in the scenario provided, I thought a BST would be the most efficient solution. It did occur to me, however, that a hashtable may be a better solution if there were a need to add courses to the set or if sorting the set were less important. Understanding the options available when considering what structure to use for a solution is important because it has a significant impact on both the runtime of the program, as-well as its overall design. 

# How did you overcome any roadblocks you encountered while going through the activities or project?
  University tutoring resources were particularly valuable to me towards the end when I began debugging, as they forced me to reconsider and critically examine some of the design decisions I was making. However, the biggest roadblocks I encountered which delayed the delivery of the last project had more to do with the IDE and my relative unfamiliarity with the errors it sent back (which all had to do with me using incorrect settings for binary parsers and compilers... whoops)
  
# How has your work on this project expanded your approach to designing software and developing programs?
  Mostly, I was reminded how valuable an outside perspective or tester can be to a project. While I had made good design decisions and few errors this time, having to explain/defend those decisions reinforced the good ones, likely would have exposed any particularly poor ones, and in this case was instrumental in reminding me how to fix the last bug I was encountering. 
  
# How has your work on this project evolved the way you write programs that are maintainable, readable, and adaptable?
  In the future, I imagine I will give more consideration to what structures to use in the design phase, as well as being more willing to write pseudocode before jumping into implementing any real code to expose any glaring design flaws while they're easier/less costly to fix.
